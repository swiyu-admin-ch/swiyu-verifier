/*
 * SPDX-FileCopyrightText: 2025 Swiss Confederation
 *
 * SPDX-License-Identifier: MIT
 */

package ch.admin.bj.swiyu.verifier.pact;

import au.com.dius.pact.provider.junit5.PactVerificationContext;
import au.com.dius.pact.provider.junit5.PactVerificationInvocationContextProvider;
import au.com.dius.pact.provider.junitsupport.Provider;
import au.com.dius.pact.provider.junitsupport.State;
import au.com.dius.pact.provider.junitsupport.loader.PactFolder;
import au.com.dius.pact.provider.spring.junit5.MockMvcTestTarget;
import ch.admin.bj.swiyu.verifier.Application;
import ch.admin.bj.swiyu.verifier.PostgreSQLContainerInitializer;
import ch.admin.bj.swiyu.verifier.domain.management.Management;
import ch.admin.bj.swiyu.verifier.domain.management.ManagementRepository;
import ch.admin.bj.swiyu.verifier.domain.management.PresentationDefinition;
import ch.admin.bj.swiyu.verifier.domain.management.VerificationStatus;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.TestTemplate;
import org.junit.jupiter.api.extension.ExtendWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.web.servlet.MockMvc;
import org.testcontainers.junit.jupiter.Testcontainers;

import java.util.List;
import java.util.UUID;

/**
 * Pact Provider Test for Verifier Application.
 * This test verifies that the verifier-application (provider) fulfills the contracts
 * defined by its consumers (e.g., wallets, external verifiers).
 *
 * The test can load pacts from:
 * 1. Local folder (for development) - using @PactFolder
 * 2. Pact Broker (for CI/CD) - using @PactBroker
 *
 * This test verifies the actual HTTP endpoints provided by the verifier application.
 */
@SpringBootTest(
    webEnvironment = SpringBootTest.WebEnvironment.MOCK,
    classes = Application.class
)
@AutoConfigureMockMvc
@ActiveProfiles("test")
@Testcontainers
@ContextConfiguration(initializers = PostgreSQLContainerInitializer.class)
@Provider("swiyu-verifier-application")
// Use @PactFolder for local development (pacts generated by consumer tests)
@PactFolder("target/pacts")
// OR use @PactBroker for CI/CD pipeline (uncomment when broker is configured)
// @PactBroker(host = "${pactbroker.host:localhost}", port = "${pactbroker.port:9292}",
//             authentication = @PactBrokerAuth(token = "${pactbroker.auth.token}"))
class VerifierApplicationProviderPactTest {

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private ManagementRepository managementRepository;

    // UUIDs that match the ones in the consumer tests
    private static final UUID TEST_REQUEST_ID_JSON = UUID.fromString("550e8400-e29b-41d4-a716-446655440000");


    @BeforeEach
    void setUp(PactVerificationContext context) {
        // Use MockMvc for testing Spring MVC controllers
        context.setTarget(new MockMvcTestTarget(mockMvc));

        // Clean up before each test
        managementRepository.deleteAll();
    }

    @TestTemplate
    @ExtendWith(PactVerificationInvocationContextProvider.class)
    void pactVerificationTestTemplate(PactVerificationContext context) {
        // This method is called for each interaction defined in the pact files
        context.verifyInteraction();
    }

    @State("a valid request object exists for the given request_id")
    public void setupValidRequestObjectExists() {
        // Create an input descriptor (same as in setupValidSignedRequestObjectExists)
        var inputDescriptor = PresentationDefinition.InputDescriptor.builder()
                .id("input_1")
                .build();

        // Create presentation definition with the input descriptor
        var presentationDefinition = PresentationDefinition.builder()
                .id(TEST_REQUEST_ID_JSON.toString())
                .name("Test Verification")
                .purpose("Test purpose")
                .inputDescriptors(List.of(inputDescriptor))  // ← Add the descriptor here
                .build();

        Management management = Management.builder()
                .id(TEST_REQUEST_ID_JSON)
                .requestNonce("n-0S6_WzA2Mj")
                .state(VerificationStatus.PENDING)
                .requestedPresentation(presentationDefinition)  // ← Use the presentation definition
                .walletResponse(null)
                .expirationInSeconds(3600)
                .expiresAt(System.currentTimeMillis() + 3600000L)
                .acceptedIssuerDids(List.of("did:example:issuer"))
                .jwtSecuredAuthorizationRequest(false)  // JAR disabled = JSON response
                .build();

        managementRepository.save(management);
        System.out.println("Setting up state: a valid request object exists (JSON) with ID: " + TEST_REQUEST_ID_JSON);
    }

    /**
     * Cleanup after each test to ensure test isolation.
     */
    @State("cleanup")
    public void cleanup() {
        // Clean up any test data
        System.out.println("Cleaning up test state");
    }
}

